// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: testdata/tests.proto

package testdata

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/golang/protobuf/ptypes/timestamp"
	_ "github.com/jackskj/protoc-gen-map/examples"
	math "math"

	//protoc-gen-map packages
	bytes "bytes"
	context "context"
	sql "database/sql"
	sprig "github.com/Masterminds/sprig"
	examples "github.com/jackskj/protoc-gen-map/examples"
	mapper "github.com/jackskj/protoc-gen-map/mapper"
	mappertmpl "github.com/jackskj/protoc-gen-map/templates"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	log "log"
	sync "sync"
	template "text/template"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// Code generated by protoc-gen-map. DO NOT EDIT.
// To Use:
// 1. Instantiate MapperServers with sql.DB connection
// 2. Register MapperServer as the gRPC service server
// 3. Begin serving

type TestReflectServiceMapServer struct {
	DB                   *sql.DB
	IncorrectTypesMapper *mapper.Mapper
	TypeCastingMapper    *mapper.Mapper

	mapperGenMux sync.Mutex
}

func (m *TestReflectServiceMapServer) TypeCasting(ctx context.Context, r *EmptyRequest) (*TypeCastingResponse, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "TypeCasting", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()

	rows, err := m.DB.Query(rawSql)
	defer rows.Close()
	if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n,query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	if m.TypeCastingMapper == nil {
		m.mapperGenMux.Lock()
		m.TypeCastingMapper, err = mapper.New(rows, &TypeCastingResponse{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("error generating TypeCastingMapper: %s", err)
			return nil, status.Error(codes.Internal, "error generating TypeCastingResponse mapping")
		}
		m.TypeCastingMapper.Log()
	}
	respMap := m.TypeCastingMapper.NewResponseMapping()
	if err := m.TypeCastingMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for TypeCasting: %s", err)
		return nil, status.Error(codes.Internal, "error loading data")
	}
	if err := m.TypeCastingMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig TypeCastingMapper: %s", err)
		m.TypeCastingMapper.Error = nil
		return nil, status.Error(codes.Internal, "error mappig TypeCastingResponse")
	}
	m.TypeCastingMapper.Log()
	if len(respMap.Responses) == 0 {
		//No Responses found
		return new(TypeCastingResponse), nil
	} else {
		return respMap.Responses[0].(*TypeCastingResponse), nil
	}

}

func (m *TestReflectServiceMapServer) IncorrectTypes(ctx context.Context, r *TypeRequest) (*GoTypesResponse, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "IncorrectTypes", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()

	rows, err := m.DB.Query(rawSql)
	defer rows.Close()
	if err != nil {
		log.Printf("error executing query.\n TypeRequest request: %s \n,query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	if m.IncorrectTypesMapper == nil {
		m.mapperGenMux.Lock()
		m.IncorrectTypesMapper, err = mapper.New(rows, &GoTypesResponse{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("error generating IncorrectTypesMapper: %s", err)
			return nil, status.Error(codes.Internal, "error generating GoTypesResponse mapping")
		}
		m.IncorrectTypesMapper.Log()
	}
	respMap := m.IncorrectTypesMapper.NewResponseMapping()
	if err := m.IncorrectTypesMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for IncorrectTypes: %s", err)
		return nil, status.Error(codes.Internal, "error loading data")
	}
	if err := m.IncorrectTypesMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig IncorrectTypesMapper: %s", err)
		m.IncorrectTypesMapper.Error = nil
		return nil, status.Error(codes.Internal, "error mappig GoTypesResponse")
	}
	m.IncorrectTypesMapper.Log()
	if len(respMap.Responses) == 0 {
		//No Responses found
		return new(GoTypesResponse), nil
	} else {
		return respMap.Responses[0].(*GoTypesResponse), nil
	}

}

type TestMappingServiceMapServer struct {
	DB                            *sql.DB
	AssociationInCollectionMapper *mapper.Mapper
	CollectionInAssociationMapper *mapper.Mapper
	EmptyNestedFieldMapper        *mapper.Mapper
	EmptyQueryMapper              *mapper.Mapper
	ExecAsQueryMapper             *mapper.Mapper
	InsertQueryAsExecMapper       *mapper.Mapper
	MultipleRespForUnaryMapper    *mapper.Mapper
	NoMatchingColumnsMapper       *mapper.Mapper
	NullResoultsForSubmapsMapper  *mapper.Mapper
	RepeatedAssociationsMapper    *mapper.Mapper
	RepeatedEmptyMapper           *mapper.Mapper
	RepeatedPrimativeMapper       *mapper.Mapper
	RepeatedTimestampMapper       *mapper.Mapper
	UnclaimedColumnsMapper        *mapper.Mapper

	mapperGenMux sync.Mutex
}

func (m *TestMappingServiceMapServer) RepeatedAssociations(ctx context.Context, r *EmptyRequest) (*RepeatedAssociationsResponse, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "RepeatedAssociations", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()

	rows, err := m.DB.Query(rawSql)
	defer rows.Close()
	if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n,query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	if m.RepeatedAssociationsMapper == nil {
		m.mapperGenMux.Lock()
		m.RepeatedAssociationsMapper, err = mapper.New(rows, &RepeatedAssociationsResponse{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("error generating RepeatedAssociationsMapper: %s", err)
			return nil, status.Error(codes.Internal, "error generating RepeatedAssociationsResponse mapping")
		}
		m.RepeatedAssociationsMapper.Log()
	}
	respMap := m.RepeatedAssociationsMapper.NewResponseMapping()
	if err := m.RepeatedAssociationsMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for RepeatedAssociations: %s", err)
		return nil, status.Error(codes.Internal, "error loading data")
	}
	if err := m.RepeatedAssociationsMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig RepeatedAssociationsMapper: %s", err)
		m.RepeatedAssociationsMapper.Error = nil
		return nil, status.Error(codes.Internal, "error mappig RepeatedAssociationsResponse")
	}
	m.RepeatedAssociationsMapper.Log()
	if len(respMap.Responses) == 0 {
		//No Responses found
		return new(RepeatedAssociationsResponse), nil
	} else {
		return respMap.Responses[0].(*RepeatedAssociationsResponse), nil
	}

}

func (m *TestMappingServiceMapServer) EmptyQuery(ctx context.Context, r *EmptyRequest) (*SampleResponse, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "EmptyQuery", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()

	rows, err := m.DB.Query(rawSql)
	defer rows.Close()
	if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n,query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	if m.EmptyQueryMapper == nil {
		m.mapperGenMux.Lock()
		m.EmptyQueryMapper, err = mapper.New(rows, &SampleResponse{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("error generating EmptyQueryMapper: %s", err)
			return nil, status.Error(codes.Internal, "error generating SampleResponse mapping")
		}
		m.EmptyQueryMapper.Log()
	}
	respMap := m.EmptyQueryMapper.NewResponseMapping()
	if err := m.EmptyQueryMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for EmptyQuery: %s", err)
		return nil, status.Error(codes.Internal, "error loading data")
	}
	if err := m.EmptyQueryMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig EmptyQueryMapper: %s", err)
		m.EmptyQueryMapper.Error = nil
		return nil, status.Error(codes.Internal, "error mappig SampleResponse")
	}
	m.EmptyQueryMapper.Log()
	if len(respMap.Responses) == 0 {
		//No Responses found
		return new(SampleResponse), nil
	} else {
		return respMap.Responses[0].(*SampleResponse), nil
	}

}

func (m *TestMappingServiceMapServer) InsertQueryAsExec(ctx context.Context, r *EmptyRequest) (*examples.Author, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "InsertQueryAsExec", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()

	_, err := m.DB.Exec(rawSql)
	if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n,query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	resp := examples.Author{}
	return &resp, nil

}

func (m *TestMappingServiceMapServer) ExecAsQuery(ctx context.Context, r *EmptyRequest) (*SampleResponse, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "ExecAsQuery", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()

	rows, err := m.DB.Query(rawSql)
	defer rows.Close()
	if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n,query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	if m.ExecAsQueryMapper == nil {
		m.mapperGenMux.Lock()
		m.ExecAsQueryMapper, err = mapper.New(rows, &SampleResponse{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("error generating ExecAsQueryMapper: %s", err)
			return nil, status.Error(codes.Internal, "error generating SampleResponse mapping")
		}
		m.ExecAsQueryMapper.Log()
	}
	respMap := m.ExecAsQueryMapper.NewResponseMapping()
	if err := m.ExecAsQueryMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for ExecAsQuery: %s", err)
		return nil, status.Error(codes.Internal, "error loading data")
	}
	if err := m.ExecAsQueryMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig ExecAsQueryMapper: %s", err)
		m.ExecAsQueryMapper.Error = nil
		return nil, status.Error(codes.Internal, "error mappig SampleResponse")
	}
	m.ExecAsQueryMapper.Log()
	if len(respMap.Responses) == 0 {
		//No Responses found
		return new(SampleResponse), nil
	} else {
		return respMap.Responses[0].(*SampleResponse), nil
	}

}

func (m *TestMappingServiceMapServer) UnclaimedColumns(ctx context.Context, r *EmptyRequest) (*AuthorUserNameResponse, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "UnclaimedColumns", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()

	rows, err := m.DB.Query(rawSql)
	defer rows.Close()
	if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n,query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	if m.UnclaimedColumnsMapper == nil {
		m.mapperGenMux.Lock()
		m.UnclaimedColumnsMapper, err = mapper.New(rows, &AuthorUserNameResponse{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("error generating UnclaimedColumnsMapper: %s", err)
			return nil, status.Error(codes.Internal, "error generating AuthorUserNameResponse mapping")
		}
		m.UnclaimedColumnsMapper.Log()
	}
	respMap := m.UnclaimedColumnsMapper.NewResponseMapping()
	if err := m.UnclaimedColumnsMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for UnclaimedColumns: %s", err)
		return nil, status.Error(codes.Internal, "error loading data")
	}
	if err := m.UnclaimedColumnsMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig UnclaimedColumnsMapper: %s", err)
		m.UnclaimedColumnsMapper.Error = nil
		return nil, status.Error(codes.Internal, "error mappig AuthorUserNameResponse")
	}
	m.UnclaimedColumnsMapper.Log()
	if len(respMap.Responses) == 0 {
		//No Responses found
		return new(AuthorUserNameResponse), nil
	} else {
		return respMap.Responses[0].(*AuthorUserNameResponse), nil
	}

}

func (m *TestMappingServiceMapServer) MultipleRespForUnary(ctx context.Context, r *EmptyRequest) (*examples.Author, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "MultipleRespForUnary", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()

	rows, err := m.DB.Query(rawSql)
	defer rows.Close()
	if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n,query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	if m.MultipleRespForUnaryMapper == nil {
		m.mapperGenMux.Lock()
		m.MultipleRespForUnaryMapper, err = mapper.New(rows, &examples.Author{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("error generating MultipleRespForUnaryMapper: %s", err)
			return nil, status.Error(codes.Internal, "error generating examples.Author mapping")
		}
		m.MultipleRespForUnaryMapper.Log()
	}
	respMap := m.MultipleRespForUnaryMapper.NewResponseMapping()
	if err := m.MultipleRespForUnaryMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for MultipleRespForUnary: %s", err)
		return nil, status.Error(codes.Internal, "error loading data")
	}
	if err := m.MultipleRespForUnaryMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig MultipleRespForUnaryMapper: %s", err)
		m.MultipleRespForUnaryMapper.Error = nil
		return nil, status.Error(codes.Internal, "error mappig examples.Author")
	}
	m.MultipleRespForUnaryMapper.Log()
	if len(respMap.Responses) == 0 {
		//No Responses found
		return new(examples.Author), nil
	} else {
		return respMap.Responses[0].(*examples.Author), nil
	}

}

func (m *TestMappingServiceMapServer) RepeatedPrimative(ctx context.Context, r *EmptyRequest) (*RepeatedPrimativeResponse, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "RepeatedPrimative", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()

	rows, err := m.DB.Query(rawSql)
	defer rows.Close()
	if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n,query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	if m.RepeatedPrimativeMapper == nil {
		m.mapperGenMux.Lock()
		m.RepeatedPrimativeMapper, err = mapper.New(rows, &RepeatedPrimativeResponse{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("error generating RepeatedPrimativeMapper: %s", err)
			return nil, status.Error(codes.Internal, "error generating RepeatedPrimativeResponse mapping")
		}
		m.RepeatedPrimativeMapper.Log()
	}
	respMap := m.RepeatedPrimativeMapper.NewResponseMapping()
	if err := m.RepeatedPrimativeMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for RepeatedPrimative: %s", err)
		return nil, status.Error(codes.Internal, "error loading data")
	}
	if err := m.RepeatedPrimativeMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig RepeatedPrimativeMapper: %s", err)
		m.RepeatedPrimativeMapper.Error = nil
		return nil, status.Error(codes.Internal, "error mappig RepeatedPrimativeResponse")
	}
	m.RepeatedPrimativeMapper.Log()
	if len(respMap.Responses) == 0 {
		//No Responses found
		return new(RepeatedPrimativeResponse), nil
	} else {
		return respMap.Responses[0].(*RepeatedPrimativeResponse), nil
	}

}

func (m *TestMappingServiceMapServer) RepeatedEmpty(ctx context.Context, r *EmptyRequest) (*RepeatedEmptyResponse, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "RepeatedEmpty", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()

	rows, err := m.DB.Query(rawSql)
	defer rows.Close()
	if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n,query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	if m.RepeatedEmptyMapper == nil {
		m.mapperGenMux.Lock()
		m.RepeatedEmptyMapper, err = mapper.New(rows, &RepeatedEmptyResponse{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("error generating RepeatedEmptyMapper: %s", err)
			return nil, status.Error(codes.Internal, "error generating RepeatedEmptyResponse mapping")
		}
		m.RepeatedEmptyMapper.Log()
	}
	respMap := m.RepeatedEmptyMapper.NewResponseMapping()
	if err := m.RepeatedEmptyMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for RepeatedEmpty: %s", err)
		return nil, status.Error(codes.Internal, "error loading data")
	}
	if err := m.RepeatedEmptyMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig RepeatedEmptyMapper: %s", err)
		m.RepeatedEmptyMapper.Error = nil
		return nil, status.Error(codes.Internal, "error mappig RepeatedEmptyResponse")
	}
	m.RepeatedEmptyMapper.Log()
	if len(respMap.Responses) == 0 {
		//No Responses found
		return new(RepeatedEmptyResponse), nil
	} else {
		return respMap.Responses[0].(*RepeatedEmptyResponse), nil
	}

}

func (m *TestMappingServiceMapServer) EmptyNestedField(ctx context.Context, r *EmptyRequest) (*NestedFieldResponse, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "EmptyNestedField", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()

	rows, err := m.DB.Query(rawSql)
	defer rows.Close()
	if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n,query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	if m.EmptyNestedFieldMapper == nil {
		m.mapperGenMux.Lock()
		m.EmptyNestedFieldMapper, err = mapper.New(rows, &NestedFieldResponse{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("error generating EmptyNestedFieldMapper: %s", err)
			return nil, status.Error(codes.Internal, "error generating NestedFieldResponse mapping")
		}
		m.EmptyNestedFieldMapper.Log()
	}
	respMap := m.EmptyNestedFieldMapper.NewResponseMapping()
	if err := m.EmptyNestedFieldMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for EmptyNestedField: %s", err)
		return nil, status.Error(codes.Internal, "error loading data")
	}
	if err := m.EmptyNestedFieldMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig EmptyNestedFieldMapper: %s", err)
		m.EmptyNestedFieldMapper.Error = nil
		return nil, status.Error(codes.Internal, "error mappig NestedFieldResponse")
	}
	m.EmptyNestedFieldMapper.Log()
	if len(respMap.Responses) == 0 {
		//No Responses found
		return new(NestedFieldResponse), nil
	} else {
		return respMap.Responses[0].(*NestedFieldResponse), nil
	}

}

func (m *TestMappingServiceMapServer) NoMatchingColumns(ctx context.Context, r *EmptyRequest) (*examples.Author, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "NoMatchingColumns", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()

	rows, err := m.DB.Query(rawSql)
	defer rows.Close()
	if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n,query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	if m.NoMatchingColumnsMapper == nil {
		m.mapperGenMux.Lock()
		m.NoMatchingColumnsMapper, err = mapper.New(rows, &examples.Author{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("error generating NoMatchingColumnsMapper: %s", err)
			return nil, status.Error(codes.Internal, "error generating examples.Author mapping")
		}
		m.NoMatchingColumnsMapper.Log()
	}
	respMap := m.NoMatchingColumnsMapper.NewResponseMapping()
	if err := m.NoMatchingColumnsMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for NoMatchingColumns: %s", err)
		return nil, status.Error(codes.Internal, "error loading data")
	}
	if err := m.NoMatchingColumnsMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig NoMatchingColumnsMapper: %s", err)
		m.NoMatchingColumnsMapper.Error = nil
		return nil, status.Error(codes.Internal, "error mappig examples.Author")
	}
	m.NoMatchingColumnsMapper.Log()
	if len(respMap.Responses) == 0 {
		//No Responses found
		return new(examples.Author), nil
	} else {
		return respMap.Responses[0].(*examples.Author), nil
	}

}

func (m *TestMappingServiceMapServer) AssociationInCollection(ctx context.Context, r *EmptyRequest) (*AssociationInCollectionResponse, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "AssociationInCollection", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()

	rows, err := m.DB.Query(rawSql)
	defer rows.Close()
	if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n,query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	if m.AssociationInCollectionMapper == nil {
		m.mapperGenMux.Lock()
		m.AssociationInCollectionMapper, err = mapper.New(rows, &AssociationInCollectionResponse{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("error generating AssociationInCollectionMapper: %s", err)
			return nil, status.Error(codes.Internal, "error generating AssociationInCollectionResponse mapping")
		}
		m.AssociationInCollectionMapper.Log()
	}
	respMap := m.AssociationInCollectionMapper.NewResponseMapping()
	if err := m.AssociationInCollectionMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for AssociationInCollection: %s", err)
		return nil, status.Error(codes.Internal, "error loading data")
	}
	if err := m.AssociationInCollectionMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig AssociationInCollectionMapper: %s", err)
		m.AssociationInCollectionMapper.Error = nil
		return nil, status.Error(codes.Internal, "error mappig AssociationInCollectionResponse")
	}
	m.AssociationInCollectionMapper.Log()
	if len(respMap.Responses) == 0 {
		//No Responses found
		return new(AssociationInCollectionResponse), nil
	} else {
		return respMap.Responses[0].(*AssociationInCollectionResponse), nil
	}

}

func (m *TestMappingServiceMapServer) CollectionInAssociation(ctx context.Context, r *EmptyRequest) (*CollectionInAssociationResponse, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "CollectionInAssociation", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()

	rows, err := m.DB.Query(rawSql)
	defer rows.Close()
	if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n,query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	if m.CollectionInAssociationMapper == nil {
		m.mapperGenMux.Lock()
		m.CollectionInAssociationMapper, err = mapper.New(rows, &CollectionInAssociationResponse{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("error generating CollectionInAssociationMapper: %s", err)
			return nil, status.Error(codes.Internal, "error generating CollectionInAssociationResponse mapping")
		}
		m.CollectionInAssociationMapper.Log()
	}
	respMap := m.CollectionInAssociationMapper.NewResponseMapping()
	if err := m.CollectionInAssociationMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for CollectionInAssociation: %s", err)
		return nil, status.Error(codes.Internal, "error loading data")
	}
	if err := m.CollectionInAssociationMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig CollectionInAssociationMapper: %s", err)
		m.CollectionInAssociationMapper.Error = nil
		return nil, status.Error(codes.Internal, "error mappig CollectionInAssociationResponse")
	}
	m.CollectionInAssociationMapper.Log()
	if len(respMap.Responses) == 0 {
		//No Responses found
		return new(CollectionInAssociationResponse), nil
	} else {
		return respMap.Responses[0].(*CollectionInAssociationResponse), nil
	}

}

func (m *TestMappingServiceMapServer) RepeatedTimestamp(ctx context.Context, r *EmptyRequest) (*RepeatedTimestampResponse, error) {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "RepeatedTimestamp", r); err != nil {
		return nil, status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()

	rows, err := m.DB.Query(rawSql)
	defer rows.Close()
	if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n,query: %s \n error: %s", r, rawSql, err)
		return nil, status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	if m.RepeatedTimestampMapper == nil {
		m.mapperGenMux.Lock()
		m.RepeatedTimestampMapper, err = mapper.New(rows, &RepeatedTimestampResponse{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("error generating RepeatedTimestampMapper: %s", err)
			return nil, status.Error(codes.Internal, "error generating RepeatedTimestampResponse mapping")
		}
		m.RepeatedTimestampMapper.Log()
	}
	respMap := m.RepeatedTimestampMapper.NewResponseMapping()
	if err := m.RepeatedTimestampMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for RepeatedTimestamp: %s", err)
		return nil, status.Error(codes.Internal, "error loading data")
	}
	if err := m.RepeatedTimestampMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig RepeatedTimestampMapper: %s", err)
		m.RepeatedTimestampMapper.Error = nil
		return nil, status.Error(codes.Internal, "error mappig RepeatedTimestampResponse")
	}
	m.RepeatedTimestampMapper.Log()
	if len(respMap.Responses) == 0 {
		//No Responses found
		return new(RepeatedTimestampResponse), nil
	} else {
		return respMap.Responses[0].(*RepeatedTimestampResponse), nil
	}

}

func (m *TestMappingServiceMapServer) NullResoultsForSubmaps(r *EmptyRequest, stream TestMappingService_NullResoultsForSubmapsServer) error {
	sqlBuffer := &bytes.Buffer{}
	if err := sqlTemplate.ExecuteTemplate(sqlBuffer, "NullResoultsForSubmaps", r); err != nil {
		return status.Error(codes.InvalidArgument, err.Error())
	}
	rawSql := sqlBuffer.String()
	rows, err := m.DB.Query(rawSql)
	defer rows.Close()
	if err != nil {
		log.Printf("error executing query.\n EmptyRequest request: %s \n,query: %s \n error: %s", r, rawSql, err)
		return status.Error(codes.InvalidArgument, "request generated malformed query")
	}
	if m.NullResoultsForSubmapsMapper == nil {
		m.mapperGenMux.Lock()
		m.NullResoultsForSubmapsMapper, err = mapper.New(rows, &examples.Post{})
		m.mapperGenMux.Unlock()
		if err != nil {
			log.Printf("error generating NullResoultsForSubmapsMapper: %s", err)
			return status.Error(codes.Internal, "error generating examples.Post mapping")
		}
		m.NullResoultsForSubmapsMapper.Log()
	}
	respMap := m.NullResoultsForSubmapsMapper.NewResponseMapping()
	if err := m.NullResoultsForSubmapsMapper.GetValues(rows, respMap); err != nil {
		log.Printf("error loading data for NullResoultsForSubmaps: %s", err)
		return status.Error(codes.Internal, "error loading data")
	}
	if err := m.NullResoultsForSubmapsMapper.MapResponse(respMap); err != nil {
		log.Printf("error mappig NullResoultsForSubmapsMapper: %s", err)
		m.NullResoultsForSubmapsMapper.Error = nil
		return status.Error(codes.Internal, "error mappig examples.Post")
	}
	m.NullResoultsForSubmapsMapper.Log()
	for _, resp := range respMap.Responses {
		if err := stream.Send(resp.(*examples.Post)); err != nil {
			return err
		}
	}
	return nil
}

var sqlTemplate, _ = template.New("sqlTemplate").Funcs(sprig.TxtFuncMap()).Funcs(mappertmpl.Funcs()).Parse(`
{{ define "RepeatedAssociations" }}
select
       B.id         as  blog_id,
       P.id         as  post_id,
       P.blog_id    as  post_blog_id,
       P.author_id  as  post_author_id,
       P.created_on as  post_created_on,
       P.section    as  post_section,
       P.subject    as  post_subject,
       P.draft      as  draft,
       P.body       as  post_body
from blog B
       left outer join post P on  B.id = P.blog_id
where B.id = 1
{{ end }}

{{ define "EmptyQuery" }}
{{ end }}

{{ define "InsertQueryAsExec" }}
select
       A.username          as  author_username,
       A.password          as  author_password,
       A.email             as  author_email,
       A.bio               as  author_bio,
       A.favourite_section as  author_favourite_section
from author A where id = 1
{{ end }}

{{ define "ExecAsQuery" }}
drop table if exists execasquery;
create table execasquery
(
  id                int
);
{{ end }}

{{ define "UnclaimedColumns" }}
select
       A.username          as  author_username,
       A.password          as  author_password
from author A where id = 1
{{ end }}

{{ define "MultipleRespForUnary" }}
select
       A.username          as  author_username,
       A.password          as  author_password,
       A.email             as  author_email,
       A.bio               as  author_bio,
       A.favourite_section as  author_favourite_section
from author A where id in (1,2)
{{ end }}

{{ define "RepeatedPrimative" }}
{{ end }}

{{ define "RepeatedEmpty" }}
select id as blog_id from blog limit 1
{{ end }}

{{ define "RepeatedTimestamp" }}
select
       B.id         as  blog_id,
       P.created_on as  post_created_on
from blog B
       left outer join post P on  B.id = P.blog_id
{{ end }}

{{ define "EmptyNestedField" }}
select id as  blog_id from blog limit 1
{{ end }}


{{ define "NoMatchingColumns" }}
select
       B.id as  blog_id,
       B.title as  blog_title
from blog B
{{ end }}

{{ define "AssociationInCollection" }}
select
        T.id as tag_id,
        P.id as post_id,
        B.id as blog_id
from tag T
        left outer join post_tag PT on PT.tag_id = T.id
        left outer join post P      on PT.post_id = P.id
        left outer join blog B      on P.blog_id = B.id
where T.id = 1
{{ end }}

{{ define "CollectionInAssociation" }}
select
        1 as dummy_var,
        B.id as  blog_id,
        B.title as  blog_title,
        A.id                as  author_id,
        A.username          as  author_username,
        A.password          as  author_password,
        A.email             as  author_email,
        A.bio               as  author_bio,
        A.favourite_section as  author_favourite_section
from blog B
       left outer join author A on  B.author_id = A.id
{{ end }}

{{ define "NullResoultsForSubmaps" }}
select
        PT.post_id as  post_id,
        P.id       as  id,
        C.id       as  comment_id,
        C.post_id  as  comment_post_id,
        C.comment  as  comment_text
from post_tag PT
       left outer join post P      on  PT.post_id = P.id
       left outer join comment C   on  P.id = C.post_id
where C.comment is null
{{ end }}
{{ define "TypeCasting" }}
select
	1.1  as  double_cast,  -- float64 also testing name mapping
	1.1  as  FloatCast,    -- float32
	1    as  Int32Cast,    -- int32
	1    as  Int64Cast,    -- int64
	1    as  Uint32Cast,   -- uint32
	1    as  Uint64Cast,   -- uint64
	1    as  Sint32Cast,   -- int32
	1    as  Sint64Cast,   -- int64
	1    as  Fixed32Cast,  -- uint32
	1    as  Fixed64Cast,  -- uint64
	1    as  Sfixed32Cast, -- int32
	1    as  Sfixed64Cast, -- int64
	true as  BoolCast,     -- bool
	'1'  as  StringCast,   -- string
        P.created_on as TimestampCast --time.Time
from post P limit 1
{{ end }}

{{ define "IncorrectTypes" }}
select
        {{ .TypeValue }} as GoFloat64,
        {{ .TypeValue }} as GoFloat32,
        {{ .TypeValue }} as GoInt32,
        {{ .TypeValue }} as GoInt64,
        {{ .TypeValue }} as GoUint32,
        {{ .TypeValue }} as GoUint64,
        {{ .TypeValue }} as GoBool,
        {{ .TypeValue }} as GoString,
        {{ .TypeValue }} as GoTimestamp
        {{ if eq .TypeValue "created_on" }}
        from post limit 1
        {{ end }}
{{ end }}

`)
